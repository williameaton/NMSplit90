module vani_kernel 

    use cudafor
    include "constants.h"
    contains 

    ! Subroutine on host that drives vknl
    subroutine compute_vani_sc_cuda(l, ngll, nspec, wglljac)
        use params, only: strains1, Cxyz, vani, myrank
        implicit none 
        ! IO variables
        integer :: ngll, nspec
        integer :: l, i, j, k, ispec, tl1
        real(kind=CUSTOM_REAL) :: wglljac(ngll, ngll, ngll, nspec)

        ! Local host variables
        real :: Vloc_r(2*l+1 , 2*l+1), Vloc_i(2*l+1 , 2*l+1)
        integer :: upper_diag_elem
        ! Local device variables
        real(kind=4),    device, dimension(ngll, ngll, ngll, nspec)               :: d_wglljac
        real(kind=4),    device, dimension(ngll, ngll, ngll, nspec,6, 6)          :: d_Cxyz
        real(kind=4),    device, dimension(2*l+1, 2*l+1)                          :: d_vani_real, d_vani_imag
        complex(kind=4), device, dimension(ngll, ngll, ngll, nspec, 2*l+1, 6)     :: d_strains
        logical, parameter :: use_hermitian = .false.

        ! Copy to the device: 
        Vloc_r = 0.0_4
        d_vani_real = Vloc_r   ! Zero these
        d_vani_imag = Vloc_r   ! Zero these
        d_strains   = strains1
        d_wglljac   = real(wglljac, kind=4)
        d_Cxyz      = Cxyz

        tl1 = 2*l + 1
        upper_diag_elem = (tl1+1)*tl1/2

        ! nsys profile -o mpi_cuda_profile --mpi mpirun -np 4 ./mpi_cuda_app
        ! Launching m1 x m2 x nspec blocks so that each block 
        ! deals with one m1, m2 combination for a single element
        if(ngll.eq.5)then
            if(use_hermitian)then 
                call CUDA_Vani_Herm<<<dim3(upper_diag_elem, nspec, 1), dim3(ngll,ngll,ngll)>>> & 
              (l, tl1, ngll, nspec, d_wglljac, d_strains, d_Cxyz, d_vani_real, d_vani_imag)
            else 
                call vani_knl_NGLL5<<<dim3(nspec,tl1,tl1), dim3(ngll,ngll,ngll)>>> & 
                (l, tl1, ngll, nspec, d_wglljac, d_strains, d_Cxyz, d_vani_real, d_vani_imag)
            endif 
        else 
            write(*,*)'Error. hardcoded for ngll = 5'
            stop
        endif 


        Vloc_r = d_vani_real        
        Vloc_i = d_vani_imag

        ! Add the real and imaginary components to the global Vani
        vani(1:tl1, 1:tl1) = vani(1:tl1, 1:tl1) + Vloc_r + SPLINE_iONE*Vloc_i

        if(use_hermitian)then
            do j = 2, tl1 
                do i = 1, j-1
                    vani(i,j)  = conjg(vani(j,i))
                enddo 
            enddo
        endif 



    end subroutine compute_vani_sc_cuda



    attributes(global) subroutine vani_knl_NGLL5(l1, tl1, ngll, nspec, d_wglljac, & 
                                          d_strains, d_Cxyz, d_Vani_r, d_Vani_i)
        integer, value                                      :: l1, ngll, nspec, tl1
        real(kind=4), dimension(ngll, ngll, ngll, nspec)            :: d_wglljac
        real(kind=4), dimension(ngll, ngll, ngll, nspec,6,6)       :: d_Cxyz
        complex(kind=4), dimension(ngll, ngll, ngll, nspec, tl1,6) :: d_strains
        real(kind=4), dimension(tl1, tl1)                   :: d_Vani_r, d_Vani_i

        ! internal variables
        integer         :: i, j, k, ispec, m1, m2, p, q, istat
        complex(kind=4) :: cont
        real(kind=4)    :: trash
        integer, dimension(9), parameter :: Vcont = (/1, 2, 3, 4, 4, 5, 5, 6, 6/)

        ! In shared memory: 
        complex, dimension(5,5,5,6),   shared :: s_strain_1, s_strain_2
        real,    dimension(5,5,5,6,6), shared :: s_c

        i = threadidx%x 
        j = threadidx%y
        k = threadidx%z

        ispec = blockidx%x
        m1    = blockidx%y
        m2    = blockidx%z

        if (i.gt.ngll .or. j.gt.ngll .or. k.gt.ngll) return

        ! Copy some stuff to close shared memory
        s_strain_1(i, j, k, :) = d_strains(i, j, k, ispec, m1, :)
        s_strain_2(i, j, k, :) = d_strains(i, j, k, ispec, m2, :)
        s_c(i, j, k, :, :) = d_Cxyz(i, j, k, ispec, :, :)

        call syncthreads()

        cont = (0.0_4, 0.0_4) 
        
        do p = 1, 9
            do q =1,9
                cont = cont  +  conjg(s_strain_1(i,j,k,Vcont(p))) * &
                                s_c(i,j,k,Vcont(p), Vcont(q))     * & 
                                s_strain_2(i,j,k,Vcont(q))
                enddo 
        enddo 

        cont = cont * d_wglljac(i,j,k,ispec)

        ! Extract the real and imaginary parts: 
        ! atomic add not available for complex. 
        trash = atomicadd(d_Vani_r(m1, m2),  real(cont,kind=4))
        trash = atomicadd(d_Vani_i(m1, m2),  aimag(cont))  
        
    end subroutine vani_knl_NGLL5




    attributes(global) subroutine CUDA_Vani_Herm(l1, tl1, ngll, nspec, d_wglljac, & 
                                                     d_strains, d_Cxyz, d_Vani_r, d_Vani_i)

        integer, value :: l1, ngll, nspec, tl1
        real(kind=4), dimension(ngll, ngll, ngll, nspec)            :: d_wglljac
        real(kind=4), dimension(ngll, ngll, ngll, nspec,6,6)       :: d_Cxyz
        real(kind=4), dimension(tl1, tl1)                           :: d_Vani_r, d_Vani_i
        complex(kind=4), dimension(ngll, ngll, ngll, nspec, tl1, 6) :: d_strains

        ! Local: 
        integer         :: i, j, k, ispec, m1, m2, p, q, istat, idx, start_idx
        complex(kind=4) :: cont
        real(kind=4)    :: trash
        integer, dimension(9), parameter :: Vcont = (/1, 2, 3, 4, 4, 5, 5, 6, 6/)

        ! In shared memory: 
        complex, dimension(5,5,5,6),   shared :: s_strain_1, s_strain_2
        real,    dimension(5,5,5,6,6), shared :: s_c

        i = threadidx%x 
        j = threadidx%y
        k = threadidx%z
        ! Get block index
        idx = blockIdx%x
        ispec = blockidx%y
        
        if (i.gt.ngll .or. j.gt.ngll .or. k.gt.ngll) return
    
        ! Compute the row and column this index relates to: 
        ! ROW VALUE IS m1 
        m1 = floor((((8*(idx-1) + 1)**0.5) - 1) / 2) + 1
        start_idx = m1 * (m1 + 1) / 2
        ! COL value is m2
        m2 = idx - ((m1*(m1 + 1))/2) + m1

        ! Copy some stuff to close shared memory
        s_strain_1(i, j, k, :) = d_strains(i, j, k, ispec, m1, :)
        s_strain_2(i, j, k, :) = d_strains(i, j, k, ispec, m2, :)
        s_c(i, j, k, :, :) = d_Cxyz(i, j, k, ispec, :, :)
        
        call syncthreads()

        cont = (0.0_4, 0.0_4) 
        do p = 1, 9
            do q =1,9
                cont = cont  +  conjg(s_strain_1(i,j,k,Vcont(p))) * &
                                s_c(i,j,k,Vcont(p), Vcont(q))     * & 
                                s_strain_2(i,j,k,Vcont(q))
                enddo 
        enddo 
        cont = cont * d_wglljac(i,j,k,ispec)

        ! Extract the real and imaginary parts: 
        ! atomic add not available for complex. 
        trash = atomicadd(d_Vani_r(m1, m2),  real(cont,kind=4))
        trash = atomicadd(d_Vani_i(m1, m2),  aimag(cont))

    end subroutine




end module vani_kernel